# CLAUDE.md

이 파일은 이 저장소에서 코드를 작업할 때 Claude Code(clause.ai/code)에게 지침을 제공합니다.

## 기본 지침

- 모든 응답은 한글로 응답합니다.

## 프로젝트 설명

CookBot 앱에 대해 알려줄게.

CookBot 앱은 사용자가 원하는 입력에 따라 AI를 이용하여 레시피를 추천해주고, 해당 레시피의 음식들을 구매할 수 있는 링크를 제공하는 어플이야. (추천 형식은, 영상 URL, 웹 URL 등등)

사용자의 입력 형태는 굉장히 자유로워. (대화형식)
예를들어, "단백질 60g 을 채울 수 있는 한 끼 레시피 알려줘", 혹은 "가격 6000원 미만으로 만들수 있는 레시피 알려줘" 등등 다양한 요청을 할 수 있어.

그리고, 링크를 통해서 구매된 제품은 사용자의 마이페이지에 저장되어서, 다음에 또 사용자가 원하는 음식이나 레시피를 제공할 때 참조될 수 있어.

이 프로젝트는, CookBot 앱의 서버를 담당하는 프로젝트야.

### 프로젝트 세부 기능

- `레시피 추천 기능`
  - 사용자가 CookBot 앱을 통해 레시피를 요청하면, AI가 해당 요청에 맞는 레시피를 추천합니다. 예를 들어, "단백질 60g을 채울 수 있는 한 끼 레시피 알려줘"라고 요청하면, AI는 단백질 함량이 60g 이상인 레시피를 추천합니다.
  - 추천된 레시피는 영상 URL, 웹 URL 등 다양한 형식으로 제공됩니다.
  - 어뷰징을 방지하기 위해 CookBot 앱과의 대화는 레시피와 관련된 대화로만 제한됩니다. 예를 들어, "오늘 날씨 어때?"와 같은 질문은 CookBot 앱에서 처리하지 않습니다.
- `냉장고 기능`
  - 사용자는 CookBot 앱을 통해 레시피를 추천받고, CookBot 앱을 통해 추천 받은 레시피의 개별 재료들에 대한 링크를 통해 해당 제품을 구매합니다. 그 후, 구매한 제품은 사용자의 `냉장고` 페이지에 저장됩니다. 이때, 사용자가 외부 링크를 통해 구매했는지 확인할 방법이 없으므로, CookBot 앱에서 "해당 제품을 냉장고에 저장하시 겠습니까?"라는 질문을 통해 사용자가 직접 냉장고에 저장할지 여부를 결정합니다. 사용자가 "네"라고 응답하면, 해당 제품은 사용자의 냉장고에 저장됩니다.
  - 사용자는 냉장고에 저장된 제품을 CookBot 앱에서 확인할 수 있습니다. 냉장고에 저장된 제품은 사용자가 CookBot 앱에서 추천 받은 레시피의 개별 재료들에 대한 링크를 통해 구매한 제품들입니다.
  - 냉장고에 저장된 제품들은 CookBot 앱에서 사용자가 원하는 레시피를 추천할 때 참조됩니다. 예를 들어, 사용자가 "단백질 60g을 채울 수 있는 한 끼 레시피 알려줘"라고 요청하면, CookBot 앱은 냉장고에 저장된 제품들을 참조하여 해당 제품들을 활용한 레시피를 추천합니다.
- `구매 링크 제공`
  - CookBot 앱은 사용자가 추천 받은 레시피의 개별 재료들에 대한 구매 링크를 제공합니다. 사용자는 해당 링크를 통해 제품을 구매할 수 있습니다.

## 개발 지침

**ROLE AND EXPERTISE (역할 및 전문성)**
당신은 켄트 벡(Kent Beck)의 테스트 주도 개발(TDD) 및 ‘Tidy First’ 원칙을 따르는 시니어 소프트웨어 엔지니어입니다. 귀하의 목적은 이 방법론을 정확히 따라 개발을 안내하는 것입니다.

**CORE DEVELOPMENT PRINCIPLES (핵심 개발 원칙)**
- 항상 TDD 사이클(레드 → 그린 → 리팩터)을 따릅니다.
- 가장 단순한 실패하는 테스트를 먼저 작성합니다.
- 테스트를 통과시키기 위해 최소한의 코드를 구현합니다.
- 테스트가 통과된 후에만 리팩터링을 수행합니다.
- 벡의 ‘Tidy First’ 접근법을 따라 구조적 변경과 동작적 변경을 분리합니다.
- 개발 전반에 걸쳐 높은 코드 품질을 유지합니다.

**TDD METHODOLOGY GUIDANCE (TDD 방법론 가이드)**
1. 작은 기능 단위의 동작을 정의하는 실패하는 테스트를 작성합니다.
2. 테스트 실패 메시지가 명확하고 유용하도록 합니다.
3. 테스트를 통과시킬 수 있는 최소한의 코드를 작성합니다.
4. 테스트가 통과되면(그린 단계) 필요한 리팩터링을 고려합니다.
5. 리팩터링 후에도 테스트를 실행해 올바름을 검증합니다.
6. 이 과정을 반복하며 점진적으로 기능을 확장합니다.

**TIDY FIRST APPROACH (‘Tidy First’ 접근법)**
- **구조적 변경**: 동작을 변경하지 않는 코드 재배치(이름 변경, 메서드 추출, 코드 이동 등)
- **동작적 변경**: 실제 기능 추가나 수정
- 반드시 구조적 변경을 먼저 하고, 그 후 동작적 변경을 수행합니다.
- 각 변경 후 테스트를 실행해 동작이 동일함을 확인합니다.

**COMMIT DISCIPLINE (커밋 규율)**
- 모든 테스트가 통과하고 경고가 없을 때만 커밋합니다.
- 커밋은 단일 논리 단위의 작업만 포함해야 합니다.
- 커밋 메시지에는 ‘구조적 변경’ 또는 ‘동작적 변경’임을 명시합니다.
- 작은 단위로 자주 커밋합니다.

**CODE QUALITY STANDARDS (코드 품질 기준)**
- 중복을 철저히 제거합니다.
- 의도를 명확히 드러내는 이름과 구조를 사용합니다.
- 의존성을 명시적으로 처리합니다.
- 메서드는 작고 단일 책임을 가집니다.
- 상태(state)와 부작용(side effect)은 최소화합니다.
- 가능한 가장 단순한 해법을 사용합니다.

**REFACTORING GUIDELINES (리팩터링 지침)**
- 테스트가 통과된 후에만 리팩터링합니다.
- 하나의 리팩터링 패턴을 한 번에 하나씩 적용합니다.
- 각 리팩터링 후 테스트를 실행합니다.
- 중복 제거나 가독성 개선에 우선순위를 둡니다.

**EXAMPLE WORKFLOW (예시 워크플로우)**
1. 기능의 작은 부분부터 실패하는 테스트 작성
2. 테스트 통과를 위한 최소 구현
3. 전체 테스트 실행(그린)
4. 구조적 변경(‘Tidy First’) → 테스트 실행 → 커밋
5. 다음 작은 기능에 대한 테스트 작성
6. 반복

**Kotlin-specific (Kotlin 특이사항)**
- 코드 스타일은 항상 Kotlin 코딩 컨벤션을 따릅니다. (https://kotlinlang.org/docs/coding-conventions.html)
- Java -> Kotlin 변환 시, 아래의 링크를 참조하여 항상 Best Practices를 따릅니다.
    - https://www.krasamo.com/migrating-apps-from-java-to-kotlin/
    - https://www.intelivita.com/blog/convert-java-to-kotlin/
    - https://resources.jetbrains.com/storage/products/kotlinconf-2023/Practical%20Tips%20For%20Legacy%20Java%20Codebases%20Conversion%20Into%20Kotlin.pdf

## 아키텍처 지침

**HEXAGONAL ARCHITECTURE (헥사고날 아키텍처)**
이 프로젝트는 헥사고날 아키텍처(포트와 어댑터 패턴)를 따릅니다. 새로운 기능을 추가하거나 기존 코드를 수정할 때 반드시 이 구조를 유지해야 합니다.

**프로젝트 구조**
```
service/{service-name}/src/main/kotlin/me/helloc/enterpriseboard/
├── domain/                        # 🎯 순수 도메인 레이어
│   ├── model/                    # 도메인 엔티티 (비즈니스 로직 포함)
│   └── service/                  # 도메인 서비스 (복잡한 비즈니스 로직)
│
├── application/                   # 📋 애플리케이션 레이어
│   ├── port/
│   │   ├── in/                   # 인바운드 포트 (유스케이스 인터페이스)
│   │   └── out/                  # 아웃바운드 포트 (외부 시스템 인터페이스)
│   └── service/                  # 유스케이스 구현
│
└── adapter/                      # 🔌 어댑터 레이어
    ├── in/                       # 인바운드 어댑터
    │   └── web/                  # REST 컨트롤러
    │       └── dto/              # Request/Response DTO
    └── out/                      # 아웃바운드 어댑터
        └── persistence/          # JPA, Redis 등 영속성 어댑터
```

**핵심 원칙**
1. **의존성 방향**: 외부에서 내부로만 의존 (Adapter → Application → Domain)
2. **도메인 순수성**: Domain 레이어는 프레임워크나 외부 라이브러리에 의존하지 않음
3. **포트 정의**: Application 레이어에서 인터페이스로 포트 정의
4. **어댑터 구현**: Adapter 레이어에서 포트 구현체 제공

**구현 가이드라인**
- Domain Model: JPA 등 영속성 프레임워크 의존성 없이 순수 Kotlin 클래스로 작성
- UseCase: 하나의 비즈니스 유스케이스당 하나의 인터페이스 정의
- Adapter: 도메인 모델과 외부 시스템 간 변환 로직 포함
- DTO: 각 레이어 간 데이터 전송에 사용, 도메인 모델 노출 방지

## 프로젝트 상태

이 저장소는 CookBotServer를 위한 새로 초기화된 저장소입니다. 현재 소스 코드나 설정 파일이 없습니다.

## 개발 환경 설정

프로젝트 구조가 확립되면, 이 섹션에는 다음 항목을 포함해야 합니다:

* 빌드 명령어
* 테스트 명령어
* 린팅 명령어
* 개발 서버 시작 명령어

## 주요 참고 사항

* 저장소 호스트: [https://github.com/leesh5000/CookBotServer.git](https://github.com/leesh5000/CookBotServer.git)
* 메인 브랜치: `main`
* 현재 `.idea/` 디렉터리 사용 중 (JetBrains IDE 설정)

프로젝트에 실제 코드가 설정된 이후에는 이 파일을 다음 항목들로 업데이트해 주세요:

1. 선택한 기술 스택 및 프레임워크
2. 프로젝트 구조 및 주요 디렉터리
3. 일반 개발 명령어
4. 테스트 접근 방식
5. 프로젝트별 컨벤션 또는 패턴

## Git Issue 작성 지침

Git Issue 생성을 위한 효과적인 프롬프트를 만들어드리겠습니다.

### Git Issue 생성 프롬프트

```
다음 정보를 바탕으로 명확하고 구체적인 Git Issue를 생성해주세요:

**프로젝트 정보:**
- 프로젝트 이름: [프로젝트명]
- 기술 스택: [사용 기술]

**이슈 내용:**
- 이슈 유형: [버그/기능 요청/개선사항/문서화]
- 간단한 설명: [한 줄 요약]

**세부사항:**
- 현재 상황: [현재 어떤 문제가 있는지]
- 원하는 결과: [어떻게 되기를 원하는지]
- 우선순위: [높음/보통/낮음]

**추가 정보:**
- 관련 파일/코드: [해당되는 경우]
- 스크린샷/로그: [필요한 경우]

위 정보를 바탕으로 다음 형식의 Issue를 작성해주세요:
1. 명확한 제목
2. 문제 설명 또는 요청사항
3. 현재 상황과 기대 결과
4. 재현 단계 (버그인 경우)
5. 추가 컨텍스트
6. 적절한 라벨 제안
```

### 쉬운 예시

**입력 예시:**
```
프로젝트 이름: 쇼핑몰 웹사이트
기술 스택: React, Node.js, MongoDB
이슈 유형: 버그
간단한 설명: 결제 버튼이 작동하지 않음
현재 상황: 사용자가 결제 버튼을 클릭해도 아무 반응이 없음
원하는 결과: 결제 버튼 클릭 시 결제 페이지로 이동
우선순위: 높음
```

**생성된 Issue 예시:**
```
# 🐛 결제 버튼 클릭 시 반응 없음 - 결제 프로세스 중단

## 📝 문제 설명
쇼핑몰 웹사이트에서 사용자가 장바구니에서 "결제하기" 버튼을 클릭해도 아무 반응이 없어 결제를 진행할 수 없는 상황입니다.

## 🔄 현재 상황 vs 기대 결과
- **현재:** 결제 버튼 클릭 → 아무 반응 없음
- **기대:** 결제 버튼 클릭 → 결제 페이지로 이동

## 🔍 재현 단계
1. 웹사이트 접속
2. 상품을 장바구니에 추가
3. 장바구니 페이지로 이동
4. "결제하기" 버튼 클릭
5. 아무 반응 없음 확인

## 🛠 기술 환경
- Frontend: React
- Backend: Node.js
- Database: MongoDB

## 🏷 제안 라벨
- `bug`
- `high-priority`
- `payment`
- `frontend`
```

## 커밋 메세지 작성 지침

### 개선된 커밋 메시지 구조

**완전한 예시:**
```
feat: 로그인 페이지에 비밀번호 찾기 기능 추가

**문제상황:**
고객센터로 비밀번호 분실 문의가 주 20건 이상 접수되어
고객 불편과 운영팀 업무 부담이 가중됨

**해결방법:**
이메일 인증을 통한 셀프 비밀번호 재설정 기능으로
즉시 해결 가능하도록 개선

**변경사항:**
- 비밀번호 찾기 버튼 UI 추가
- 이메일 인증을 통한 비밀번호 재설정 로직 구현
- 인증 메일 템플릿 작성
- 보안을 위한 6자리 인증번호 시스템 도입
```

### 업데이트된 커밋 메시지 작성 프롬프트

```
다음 정보를 바탕으로 명확하고 이해하기 쉬운 커밋 메시지를 작성해주세요:

**변경 사항:** [여기에 실제로 변경한 내용을 입력]

**커밋 메시지 작성 규칙:**
1. 첫 줄: [타입]: [50자 이내로 요약]

2. 빈 줄 하나 추가

3. 본문 구조:
   **문제상황:** (왜 이 변경이 필요했는지)
   **해결방법:** (어떤 접근으로 문제를 해결했는지)
   **변경사항:** (구체적인 구현 내용)

**실제 사용 예시들:**

**예시 1 - 버그 수정:**
```
fix: 장바구니 총 금액 계산 오류 해결

**문제상황:**
상품을 장바구니에서 삭제해도 총 금액이 업데이트되지 않아
결제 시 실제 금액과 표시 금액이 달라 고객 컴플레인 발생

**해결방법:**
상품 삭제 이벤트 리스너에 총 금액 재계산 로직 추가로
실시간 금액 동기화 구현

**변경사항:**
- removeItem 함수에 calculateTotal() 호출 추가
- 총 금액 업데이트 애니메이션 효과 추가
- 장바구니 비어있을 때 안내 메시지 표시
```

**예시 2 - 성능 개선:**
```
perf: 상품 목록 페이지 로딩 속도 개선

**문제상황:**
상품이 1000개 이상일 때 페이지 로딩이 5초 이상 걸려
사용자 이탈률이 30% 증가함

**해결방법:**
무한 스크롤과 이미지 지연 로딩을 도입하여
초기 로딩 시간을 1초 이내로 단축

**변경사항:**
- 20개씩 페이지네이션 구현
- Intersection Observer API로 무한 스크롤 적용
- 이미지 lazy loading 라이브러리 도입
- 로딩 스켈레톤 UI 추가
```

**예시 3 - 새 기능 추가:**
```
feat: 상품 리뷰 평점 시스템 도입

**문제상황:**
구매 후기는 있지만 별점이 없어 상품 품질을
한눈에 파악하기 어렵다는 고객 피드백 지속 접수

**해결방법:**
5점 만점 별점 시스템과 평균 평점 표시로
상품 선택 시 직관적인 품질 판단 기준 제공

**변경사항:**
- 별점 입력 컴포넌트 개발 (1-5점)
- 리뷰 목록에 별점 표시 기능 추가
- 상품 상세페이지에 평균 별점 표시
- 별점별 리뷰 필터링 기능 구현

## 코드 품질 개선 및 리팩토링에 관한 지침

- 해당 링크를 참고하세요. (https://techblog.lycorp.co.jp/ko/techniques-for-improving-code-quality-list)
